#!/bin/bash

# ARG_OPTIONAL_SINGLE([region],[r],[AWS Region],[eu-central-1])
# ARG_OPTIONAL_SINGLE([department],[d],[Department code],[ccm])
# ARG_POSITIONAL_SINGLE([env],[Environment 'dev', 'test', 'prod', required])
# ARG_POSITIONAL_SINGLE([client],[Client short name, required])
# ARG_POSITIONAL_SINGLE([module],[Module to deploy, optional],[all])
# ARG_HELP([Deploy new-customer-baseline])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.6.1 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.io for more info
# Generated online by https://argbash.io/generate

die()
{
	local _ret=$2
	test -n "$_ret" || _ret=1
	test "$_PRINT_HELP" = yes && print_help >&2
	echo "$1" >&2
	exit ${_ret}
}

begins_with_short_option()
{
	local first_option all_short_options
	all_short_options='rdh'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}



# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_module="all"
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_region="eu-central-1"
_arg_department="ccm"

print_help ()
{
	printf '%s\n' "Deploy new-customer-baseline"
	printf 'Usage: %s [-r|--region <arg>] [-d|--department <arg>] [-h|--help] <env> <client> [<module>]\n' "$0"
	printf '\t%s\n' "<env>: Environment 'dev', 'test', 'prod', required"
	printf '\t%s\n' "<client>: Client short name, required"
	printf '\t%s\n' "<module>: Module to deploy, optional (default: 'all')"
	printf '\t%s\n' "-r,--region: AWS Region (default: 'eu-central-1')"
	printf '\t%s\n' "-d,--department: Department code (default: 'ccm')"
	printf '\t%s\n' "-h,--help: Prints help"
}

parse_commandline ()
{
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-r|--region)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_region="$2"
				shift
				;;
			--region=*)
				_arg_region="${_key##--region=}"
				;;
			-r*)
				_arg_region="${_key##-r}"
				;;
			-d|--department)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_department="$2"
				shift
				;;
			--department=*)
				_arg_department="${_key##--department=}"
				;;
			-d*)
				_arg_department="${_key##-d}"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			*)
				_positionals+=("$1")
				;;
		esac
		shift
	done
}


handle_passed_args_count ()
{
	_required_args_string="'env' and 'client'"
	test ${#_positionals[@]} -ge 2 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 2 and 3 (namely: $_required_args_string), but got only ${#_positionals[@]}." 1
	test ${#_positionals[@]} -le 3 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 2 and 3 (namely: $_required_args_string), but got ${#_positionals[@]} (the last one was: '${_positionals[*]: -1}')." 1
}

assign_positional_args ()
{
	_positional_names=('_arg_env' '_arg_client' '_arg_module' )

	for (( ii = 0; ii < ${#_positionals[@]}; ii++))
	do
		eval "${_positional_names[ii]}=\${_positionals[ii]}" || die "Error during argument parsing, possibly an Argbash bug." 1
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
# [ <-- needed because of Argbash
# ] <-- needed because of Argbash
